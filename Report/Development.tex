\newpage
\section{Implementation}
For a large amount of contingencies, this optimization problem becomes very complex and can take a lot of time to solve. However, most contingencies will typically not be binding. This means it is best to only include the binding contingencies in the optimization problem, as this can save a lot of computation time. The paper \cite{paper} uses the algorithm in figure \ref{fig:algorithm} to accomplish this. First, the OPF of the system is solved, this means that only the constraints for $c=0$ are considered. Then the algorithm checks the solution's feasibility all contingencies. If the solution is feasible, the PSCOPF solution has been found. If it is not, the constraints for the problematic contingencies are added to the optimization problem and the problem is solved again. Next, the feasibility of the solution is checked again. This process (steps 2-5) repeats until a feasible PSCOPF solution has been found.
\begin{figure}[h]
        \centering
        \includegraphics[width=0.5\linewidth]{Figures/Untitled.jpg}
        \caption{Algorithm for solving the PSCOPF}
        \label{fig:algorithm}
\end{figure}

This report's implementation is made using the Julia programming language, in combination with the JuMP \cite{Lubin2023} and the Gurobi solver. 

The steps in figure \ref{fig:algorithm} map to the program in the following way. The program is tied together by the main method \textbf{pscopf}, which follows the flow chart and calls the necessary methods to execute all the steps. Step 1 is implemented by the \textbf{create\_base\_model} method and a call to JuMP's \textbf{optimize!} method, the \textbf{check\_contingecies!} method represents steps 2-3 and the (\textbf{add\_contigency\_constraint!}) method is step 4. Step 5 is implemented a call to JuMP's \textbf{optimize!} method. The \textbf{recalculate\_powerflow} method is used by the \textbf{check\_contingecies!} to calculate the branch flows during a contingency. It does this by first calculating the primary response of the system by solving a MILP problem. Then, it uses these results in a DC power flow to calculate the branch flows of the system.

The program was built step by step, gradually adding functionality. First, the code for the base OPF (\textbf{create\_base\_model}) was written and validated, followed by the code for checking the solution's feasibility for each contingency (\textbf{check\_contingencies!} and \textbf{recalculate\_powerflow}). Then, the part where the problematic contingencies gets added to the optimization problem (\textbf{add\_contigency\_constraint!}), was built and finally the main function (\textbf{pscopf!}), which ties all steps together, was made.

The hardest part of the implementation was checking the correctness of the methods, especially the optimization results. Even if the optimizer says it has found an optimal solution, it might not be the correct solution, e.g. due to typo in the constraints of the JuMP model. Thus, the correctness of the methods was checked using simple cases for which the solution could be manually determined. A couple of such test cases are:
\setlength{\parskip}{0em}
\begin{itemize}
    \item Testing the primary response calculation for a system where $P^{max}_g >> P_{g0}$ for all generators, this way $\Delta P_g = D_g \cdot \Delta f$ for all generators, which can be easily manually verified. This functionality can easily be further verified by adding one generator where $P_{g0}=P^{max}_g$.
    \item Running \textbf{check\_contingencies} after \textbf{add\_contingency\_constraint!} to check whether the solution has become feasible after adding the constraints for the problematic contingencies.
    \item Testing the DC power flow calculation in \textbf{recalculate\_powerflow} by using $P^w_n$, $P^d_n$ and $P_g0$ as inputs and comparing it with the solution from the base model
\end{itemize}
\setlength{\parskip}{1.5em}