using CSV
using DataFrames
using JuMP
using Gurobi
using LinearAlgebra
using Plots
using StatsPlots

# Import data
function import_data()
    return(
        line_data            = CSV.read(joinpath(@__DIR__, "data/line_data.csv"), DataFrame),
        line_incidence       = CSV.read(joinpath(@__DIR__, "data/line_incidence.csv"), DataFrame),
        windturbine_indicator = CSV.read(joinpath(@__DIR__, "data/windturbine_incidence.csv"), DataFrame),
        wind_data            = CSV.read(joinpath(@__DIR__, "data/wind_data.csv"), DataFrame),
        generator_indicator  = CSV.read(joinpath(@__DIR__, "data/generator_incidence.csv"), DataFrame),
        generator_data       = CSV.read(joinpath(@__DIR__, "data/generator_data.csv"), DataFrame),
        load_data            = CSV.read(joinpath(@__DIR__, "data/load_data.csv"), DataFrame),
    )
end

# Create sets
function create_sets(data::NamedTuple)
    return (
        N = 1:size(data.line_incidence, 2),
        K = 1:size(data.line_incidence, 1),
        W = 1:size(data.windturbine_indicator, 1),
        G = 1:size(data.generator_indicator, 1),
        D = 1:size(data.load_data, 2));
end

# Create parameters
struct Parameters
    theta_max::Float64
    theta_min::Float64
    Iline::Matrix{Int64}
    Iwind::Matrix{Int64}
    Igen::Matrix{Int64}
    Pgmax::Vector{Float64}
    Pgmin::Vector{Float64}
    gen_fixed_cost::Vector{Float64}
    gen_variable_cost::Vector{Float64}
    Dg::Vector{Float64}
    Pd::Vector{Float64}
    Pkmax::Vector{Float64}
    B::Vector{Float64}
    Pwmax::Vector{Float64}
    M::Float64
end

function create_parameters(data::NamedTuple)
    return Parameters(
        pi/2,
        -pi/2,
        transpose(Matrix(data.line_incidence)),
        transpose(Matrix(data.windturbine_indicator)),
        transpose(Matrix(data.generator_indicator)),
        Matrix(data.generator_data)[:,1],
        Matrix(data.generator_data)[:,4],
        Matrix(data.generator_data)[:,2],
        Matrix(data.generator_data)[:,3],
        Matrix(data.generator_data)[:,1]./(50*0.05),
        transpose(Matrix(data.load_data))[:,8442],
        data.line_data.cap,
        data.line_data.B,
        transpose(Matrix(data.wind_data))[:,17],
        maximum(Matrix(data.generator_data)[:,1])*2
    );
end

#Create OPF model
function create_base_model(set::NamedTuple, param::Parameters)
    model = Model(optimizer_with_attributes(Gurobi.Optimizer));

    model[:theta] = @variable(model, theta[set.N]); # voltage angle at each node
    model[:Pg] = @variable(model, Pg[set.G]); # power generated by each generator
    #@variable(model, gen_enable[set.G], Bin); # Generator on or off
    model[:Pw] = @variable(model, Pw[set.W] >= 0); # power generated by each wind turbine
    model[:Pk] = @variable(model, Pk[set.K]); # power flow on each line

    @objective(model, Min, sum(param.gen_fixed_cost + param.gen_variable_cost.*Pg)); 

    model[:power_balance] = @constraint(model, power_balance, param.Igen * Pg + param.Iwind * Pw + param.Iline * Pk .== param.Pd); # power balance at each node
    model[:gen_upperlimit] = @constraint(model, gen_upperlimit,  Pg .<= (param.Pgmax))# .* gen_enable)); # generator limits
    model[:gen_lowerlimit] = @constraint(model, gen_lowerlimit,  Pg .>= (param.Pgmin))# .* gen_enable));
    model[:wind_limits] = @constraint(model, wind_limits, 0 .<= Pw .<= param.Pwmax); # wind turbine limits
    model[:dc_power_flow] = @constraint(model, dc_power_flow, Pk .==  param.B.* (param.Iline' * theta)); # DC power flow equations
    model[:angle_limits] = @constraint(model, angle_limits, param.theta_min .<= theta .<= param.theta_max); # voltage angle limits
    model[:line_limits] = @constraint(model, line_limits, -param.Pkmax .<= Pk .<= param.Pkmax); # line flow limits
    model[:ref_bus ] = @constraint(model, ref_bus, theta[1] .== 0); # reference bus angle

    return model
end

function recalculate_powerflow(model::Model, contingent_gen::Int64)
    Pw = Vector(value.(model[:Pw]));
    Pg_init = Vector(value.(model[:Pg])); # Before contingency
    Pg_cont = copy(Pg_init); # After contingency
    Pg_cont[contingent_gen] = 0;

    if (sum(Pg_init) == sum(Pg_cont))
        return Vector(value.(model[:Pk])); 
    end

    # Calculate Pg after Frequency containment
    FC_model = Model(optimizer_with_attributes(Gurobi.Optimizer));

    @variable(FC_model, Pg_add[model[:set].G]) # Additional generation due to freq regulation
    @variable(FC_model, gen_max[model[:set].G], Bin) # 1 if generator at max gen
    @variable(FC_model, freq_dev)

    @objective(FC_model, Min, freq_dev)

    @constraint(FC_model, max_power_limit, Pg_cont + Pg_add .<= model[:param].Pgmax)
    @constraint(FC_model, freq_regulation_lower, Pg_add .<= freq_dev .* model[:param].Dg)
    @constraint(FC_model, freq_regulation_upper, Pg_add .>= freq_dev .* model[:param].Dg .* (1 .- gen_max)) # .* gen_enable)
    #@constraint(FC_model, disabled_generators, Pg_add .* (1 .- gen_enable) == 0)
    @constraint(FC_model, power_balance, sum(Pg_cont) + sum(Pg_add) .== sum(Pg_init))

    optimize!(FC_model);

    println(termination_status(FC_model))

    if (termination_status(FC_model) == OPTIMAL)

        Pg_FC = Pg_cont + Vector(value.(Pg_add));

        # DC powerflow
        P = model[:param].Pd - model[:param].Igen * Pg_FC - model[:param].Iwind * Pw;
        B = model[:param].Iline * Diagonal(model[:param].B) * model[:param].Iline';
        theta = B \ P;

        Pk = model[:param].B .* (model[:param].Iline' * theta);

        return  Pk
    end
    return missing
end

function check_contingencies!(model::Model, unsafe_contingencies::Vector{Int64})
    new_unsafe_contingencies = Vector{Int64}();
    for i in eachindex(model[:param].Pgmax)
        if (!(i in unsafe_contingencies))
            Pkmax = model[:param].Pkmax;
            Pk_FC = recalculate_powerflow(model, i);
            if ismissing(Pk_FC)
                push!(unsafe_contingencies, i);
                push!(new_unsafe_contingencies, i);
            elseif (false in (-Pkmax .<= Pk_FC .<= Pkmax))
                push!(unsafe_contingencies, i);
                push!(new_unsafe_contingencies, i);
            end
        end
    end
    return new_unsafe_contingencies;
end

function add_contigency_constraint!(model::Model, contingent_gen::Int64)
    freq_dev = @variable(model, base_name = "freq_dev" * string(contingent_gen));
    model[Symbol("freq_dev" * string(contingent_gen))] = freq_dev
    zg = @variable(model, [model[:set].G],base_name = "zg" * string(contingent_gen), binary = true); # 1 if gen at max during contingency
    model[Symbol("zg" * string(contingent_gen))] = zg
    theta = @variable(model, [model[:set].N], base_name = "theta" * string(contingent_gen));
    model[Symbol("theta" * string(contingent_gen))] = theta    
    Pg = @variable(model, [model[:set].G], base_name = "Pg_c" * string(contingent_gen));
    model[Symbol("Pg_c" * string(contingent_gen))] = Pg
    Pk = @variable(model, [model[:set].K], base_name = "Pk_c" * string(contingent_gen));
    model[Symbol("Pk_c" * string(contingent_gen))] = Pk
    disabled_gen = ones(length(model[:param].Pgmax));
    disabled_gen[contingent_gen] = 0; 


    model[Symbol("power_balance_c" * string(contingent_gen))] = @constraint(model, base_name = "power_balance_c" * string(contingent_gen), model[:param].Igen * Pg + model[:param].Iwind * model[:Pw] + model[:param].Iline * Pk .== model[:param].Pd); # power balance at each node
    model[Symbol("gen_upperlimit_c" * string(contingent_gen))] = @constraint(model, base_name = "gen_upperlimit_c" * string(contingent_gen),  Pg .<= (model[:param].Pgmax) .* disabled_gen)# .* model[:gen_enable])); # generator limits
    model[Symbol("gen_lowerlimits_c" * string(contingent_gen))] = @constraint(model, base_name = "gen_lowerlimits_c" * string(contingent_gen),  Pg .>= (model[:param].Pgmin) .* disabled_gen)# .* model[:gen_enable]));
    model[Symbol("dc_power_flow_c" * string(contingent_gen))] = @constraint(model, base_name = "dc_power_flow_c" * string(contingent_gen), Pk .==  model[:param].B.* (model[:param].Iline' * theta)); # DC power flow equations
    model[Symbol("angle_limits_c" * string(contingent_gen))] = @constraint(model, base_name = "angle_limits_c" * string(contingent_gen), model[:param].theta_min .<= theta .<= model[:param].theta_max); # voltage angle limits
    model[Symbol("line_limits_c" * string(contingent_gen))] = @constraint(model, base_name = "line_limits_c" * string(contingent_gen), -model[:param].Pkmax .<= Pk .<= model[:param].Pkmax); # line flow limits
    model[Symbol("ref_bus_c" * string(contingent_gen))] = @constraint(model, base_name = "ref_bus_c" * string(contingent_gen), theta[1] .== 0); # reference bus angle
    model[Symbol("FR_upper_c" * string(contingent_gen))] = @constraint(model, base_name = "FR_upper_c" * string(contingent_gen), Pg .<= (model[:Pg] - freq_dev .* model[:param].Dg) .* disabled_gen)# .* model[:gen_enable])
    model[Symbol("FR_lower_c" * string(contingent_gen))] = @constraint(model, base_name = "FR_lower_c" * string(contingent_gen), Pg .>= (model[:Pg] - freq_dev .* model[:param].Dg .- model[:param].M .* zg) .* disabled_gen)# .* model[:gen_enable])
    model[Symbol("FR_limit_c" * string(contingent_gen))] = @constraint(model, base_name = "FR_limit_c" * string(contingent_gen), Pg .>= model[:param].Pgmax .* zg)
end

function pscopf!(model::Model)
    unsafe_contingencies = Vector{Int64}()
    secure = false

    i = 0;
    while (!secure)
        i += 1
        new_unsafe_contingencies = check_contingencies!(model, unsafe_contingencies);

        if (length(new_unsafe_contingencies) != 0)
            for i in new_unsafe_contingencies
                add_contigency_constraint!(model, i);
            end
        else
            secure = true;
        end

        optimize!(model);

    end
    println("Loops: ", i)
    return unsafe_contingencies
end

function analyze_pscopf(set::NamedTuple, param::Parameters)
    security_costs = Vector{Float64}();
    timings = Vector{Float64}();

    max_load = deepcopy(param.Pd);

    load_factors = 0.5:0.02:1;

    for load_factor in load_factors
        param.Pd .= max_load .* load_factor;

        model = create_base_model(set, param);
        model[:param] = param;
        model[:set] = set;

        optimize!(model);

        cost_init = objective_value(model);

        timing = @elapsed pscopf!(model);

        push!(timings, timing);

        cost_final = objective_value(model);

        push!(security_costs, (cost_final - cost_init)/cost_init * 100);
    end

    return load_factors, security_costs, timings;
end

data = import_data();
set = create_sets(data);
param = create_parameters(data);

load_factors, security_costs, timings = analyze_pscopf(set, param);

##
p1 = plot(load_factors .* 100, security_costs, xlabel = "Total Load (% of peak load)", ylabel = "Relative Security cost (%)", legend = false)
p2 = plot(load_factors .* 100, timings, xlabel = "Total Load (% of peak load)", ylabel = "Execution time [s]", legend = false)
plot(p1, p2, layout = (2, 1))
plot!(size=(600,800))